# 架构决策记录 (ADR)：自适应 Agent 策略 vs 显式工作流编排

| 文档日期 | 2026-01-29 |
| :--- | :--- |
| **项目名称** | ITS 智能运维多智能体系统 |
| **决策主题** | 检索兜底逻辑（KB -> Web）的实现模式对比与选型 |
| **当前状态** | 已采纳 (Accepted) - 模式 B |

---

## 1. 概述 (Executive Summary)

在构建 ITS 智能客服系统的“检索兜底”功能时，架构演进经历了两个阶段：

1.  **初始设计 (v1.0)**：基于 **Agentic Pattern** 的“自适应循环策略”。利用 LLM 动态判断结果质量，通过修改策略（Re-plan）在节点内部进行自旋重试。
2.  **重构设计 (v1.4)**：基于 **Workflow Pattern** 的“显式编排模式”。利用确定性的路由逻辑（Router），在图拓扑层面构建清晰的瀑布流（KB 失败 -> 立即切 Web）。

这两种设计并非简单的对错之分，而是代表了当前 AI 工程界两种截然不同的设计哲学：**“机器自适应”与“工程确定性”的权衡**。

---

## 2. 核心设计哲学对比 (Design Philosophy)

### 2.1 模式 A：自适应循环策略 (The Agentic Loop)

> **哲学**：“像专家一样思考与试错。”

*   **核心理念**：认为解决问题的路径是**不确定**的。系统不应被预设的规则束缚，而应具备“感知-行动-观察-修正”的闭环能力。
*   **实现逻辑**：
    *   **决策权下放**：完全交给 LLM（策略节点）。
    *   **拓扑极简**：图结构只有 `Plan -> Act -> Verify` 三个核心节点。
    *   **深度优先**：依靠代码深度和 Prompt 循环来解决复杂问题。如果 KB 没搜到，LLM 会“思考”：是换个词搜 KB？还是去 Web？还是问用户？
*   **比喻**：**全科医生**。看到检查结果（检索结果）不好，医生会根据经验实时决定下一步是换药还是手术，而不是照着死板的说明书操作。

### 2.2 模式 B：显式编排模式 (The Explicit Pipeline)

> **哲学**：“像流水线一样精准执行。”

*   **核心理念**：认为业务流程（SOP）是**确定**的。系统必须严格遵循预定义的业务规则（Business Logic），不容许随机性。
*   **实现逻辑**：
    *   **决策权收回**：由开发者编写的路由代码（Router）控制。
    *   **拓扑展开**：图结构复杂，分支与跳转明确（DAG）。
    *   **广度优先**：依靠拓扑广度覆盖业务场景。如果 KB 没搜到，代码逻辑直接判定：`if KB_Miss then Web_Search`。
*   **比喻**：**工厂流水线**。如果 A 站点检测不合格，传送带会自动按既定轨道把产品送到 B 站点进行返工，路径是“焊死”的。

---

## 3. 多维度详细对比 (Detailed Comparison)

| 维度 | 自适应循环 (Agentic) | 显式编排 (Workflow) | 工业级评价 |
| :--- | :--- | :--- | :--- |
| **可观测性** | **弱 (Opaque)**<br>逻辑隐藏在 Prompt 和内部重试计数器中，从 DAG 图看不出降级路径。 | **强 (Transparent)**<br>从 DAG 图一眼就能看出 `KB -> Web` 的连线，故障定位极快。 | **显式编排胜出** |
| **确定性** | **低 (Probabilistic)**<br>依赖 LLM 判决，可能出现幻觉、意外路径或死循环。 | **高 (Deterministic)**<br>代码逻辑控制流转，结果由规则保证，100% 可预测。 | **显式编排胜出** |
| **延迟与成本** | **高**<br>每次重试都需要经过 LLM 思考（Strategy Node），Token 消耗大，延迟高。 | **低**<br>路由判断是 Python 代码（if-else），毫秒级且零成本。 | **显式编排胜出** |
| **灵活性** | **极高**<br>无需修改图结构即可应对未知错误（如 KB 挂了自动切 Web）。 | **低**<br>必须预先定义好所有可能的错误路径和降级方案。 | **自适应循环胜出** |
| **复杂度分布** | **节点内部 (In-Node)**<br>图简单，但 Prompt 和节点逻辑复杂。 | **图拓扑 (In-Edge)**<br>图复杂（蜘蛛网），但节点功能单一且简单。 | **视维护习惯而定** |

---

## 4. 工业级落地场景分析 (Industrial Context)

为什么我们最终在 ITS 系统中选择了 **显式编排**？这取决于具体的业务场景属性。

### 4.1 适合“自适应循环”的场景
*   **探索性任务**：例如“自动写代码”、“撰写长篇研报”。因为无法预知代码会报什么错，必须让 Agent 自己看报错信息去尝试修复。
*   **模糊意图处理**：用户指令含糊不清，Agent 需要不断尝试不同的工具去“试探”边界。
*   **非标场景**：没有明确 SOP 的长尾问题。

### 4.2 适合“显式编排”的场景 (ITS 项目现状)
*   **标准作业程序 (SOP)**：故障诊断流程、退换货流程、**兜底机制**。
*   **硬性规则**：如本项目中的 `KB -> Web`。这是一个必须执行的业务规则，不需要 AI 思考“要不要做”。
*   **高并发与时延敏感**：客服系统对响应速度要求高，不能容忍 LLM 反复“思考”下一步该怎么走。

---

## 5. 结论 (Conclusion)

1.  **漏洞复盘**：
    之前的“自旋设计”虽然具备高度的灵活性，但在 ITS 这种强调 **SOP（标准操作流程）** 的系统中，它引入了不必要的随机性与延迟，并掩盖了关键的业务逻辑（Hidden Logic），甚至导致了“未知意图全源扫描”的安全隐患。

2.  **决策依据**：
    在工业级系统中，**确定性 > 灵活性**，**可观测性 > 智能化**。对于明确的业务降级规则，必须使用 **显式编排**。

3.  **未来演进 (Hybrid Architecture)**：
    优秀的工业系统往往是混合的：
    *   **顶层 (Top-Level)**：使用显式编排（LangGraph DAG）控制主流程、安全边界和业务规则。
    *   **底层 (Leaf-Level)**：在某个具体的“子节点”内部（如 `Complex_Solver_Node`），可以封装一个小型的自适应 Agent 来处理棘手的非标问题。

> **一句话总结**：
> 不要为了使用 Agent 而 Agent。对于**已知**的路径，用**代码（路由）**；对于**未知**的路径，才用**模型（自适应）**。
