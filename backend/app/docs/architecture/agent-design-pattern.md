# Agent 设计模式：自适应策略 vs 显式编排 & Agent-as-Tool

> 本文合并自 `agent 设计哲学.md` 和 `Agent-as-Tool设计模式.md`

---

## 第一部分：架构决策 — 自适应 Agent vs 显式工作流编排

| 文档日期 | 2026-01-29 |
| :--- | :--- |
| **项目名称** | ITS 智能运维多智能体系统 |
| **决策主题** | 检索兜底逻辑（KB -> Web）的实现模式对比与选型 |
| **当前状态** | 已采纳 (Accepted) - 模式 B |

### 1. 概述

在构建 ITS 智能客服系统的"检索兜底"功能时，架构演进经历了两个阶段：

1. **初始设计 (v1.0)**：基于 **Agentic Pattern** 的"自适应循环策略"。利用 LLM 动态判断结果质量，通过修改策略（Re-plan）在节点内部进行自旋重试。
2. **重构设计 (v1.4)**：基于 **Workflow Pattern** 的"显式编排模式"。利用确定性的路由逻辑（Router），在图拓扑层面构建清晰的瀑布流（KB 失败 -> 立即切 Web）。

这两种设计代表了当前 AI 工程界两种截然不同的设计哲学：**"机器自适应"与"工程确定性"的权衡**。

### 2. 核心设计哲学对比

#### 2.1 模式 A：自适应循环策略 (The Agentic Loop)

> **哲学**："像专家一样思考与试错。"

* **核心理念**：认为解决问题的路径是**不确定**的。系统不应被预设的规则束缚，而应具备"感知-行动-观察-修正"的闭环能力。
* **实现逻辑**：
    * **决策权下放**：完全交给 LLM（策略节点）。
    * **拓扑极简**：图结构只有 `Plan -> Act -> Verify` 三个核心节点。
    * **深度优先**：依靠代码深度和 Prompt 循环来解决复杂问题。
* **比喻**：**全科医生**。看到检查结果不好，医生会根据经验实时决定下一步。

#### 2.2 模式 B：显式编排模式 (The Explicit Pipeline)

> **哲学**："像流水线一样精准执行。"

* **核心理念**：认为业务流程（SOP）是**确定**的。系统必须严格遵循预定义的业务规则。
* **实现逻辑**：
    * **决策权收回**：由开发者编写的路由代码（Router）控制。
    * **拓扑展开**：图结构复杂，分支与跳转明确（DAG）。
    * **广度优先**：依靠拓扑广度覆盖业务场景。
* **比喻**：**工厂流水线**。如果 A 站点检测不合格，传送带自动按既定轨道送到 B 站点。

### 3. 多维度详细对比

| 维度 | 自适应循环 (Agentic) | 显式编排 (Workflow) | 工业级评价 |
| :--- | :--- | :--- | :--- |
| **可观测性** | 弱 - 逻辑隐藏在 Prompt 和内部重试中 | 强 - DAG 图一眼看出降级路径 | 显式编排胜出 |
| **确定性** | 低 - 依赖 LLM 判决，可能幻觉/死循环 | 高 - 代码逻辑控制，100% 可预测 | 显式编排胜出 |
| **延迟与成本** | 高 - 每次重试经过 LLM 思考 | 低 - 路由判断是 if-else，毫秒级 | 显式编排胜出 |
| **灵活性** | 极高 - 无需修改图结构即可应对未知错误 | 低 - 必须预先定义所有错误路径 | 自适应循环胜出 |
| **复杂度分布** | 节点内部 - 图简单但 Prompt 复杂 | 图拓扑 - 图复杂但节点简单 | 视维护习惯而定 |

### 4. 工业级落地场景分析

为什么我们最终在 ITS 系统中选择了 **显式编排**？

**适合"自适应循环"的场景**：
* 探索性任务（自动写代码、撰写长篇研报）
* 模糊意图处理
* 非标场景（没有明确 SOP 的长尾问题）

**适合"显式编排"的场景（ITS 项目现状）**：
* 标准作业程序 (SOP)：故障诊断流程、退换货流程、兜底机制
* 硬性规则：如 `KB -> Web`，必须执行的业务规则
* 高并发与时延敏感：客服系统对响应速度要求高

### 5. 结论

1. **漏洞复盘**：之前的"自旋设计"在 ITS 这种强调 SOP 的系统中引入了不必要的随机性与延迟。
2. **决策依据**：在工业级系统中，**确定性 > 灵活性**，**可观测性 > 智能化**。
3. **未来演进 (Hybrid Architecture)**：
    * **顶层**：使用显式编排（LangGraph DAG）控制主流程、安全边界和业务规则。
    * **底层**：在某个具体的"子节点"内部，可以封装一个小型的自适应 Agent 来处理棘手的非标问题。

> **一句话总结**：不要为了使用 Agent 而 Agent。对于**已知**的路径，用**代码（路由）**；对于**未知**的路径，才用**模型（自适应）**。

---

## 第二部分：Agent-as-Tool 设计模式

> 将复杂的智能体封装为简单的函数工具，实现多智能体系统的优雅协作

### 1. 问题背景

在构建多智能体系统时，调度器直接管理 Agent 对象会导致：
- 调度器需要了解每个 Agent 的实现细节
- 重复的 Runner 创建和配置代码
- 错误处理逻辑分散
- 难以测试和扩展

### 2. 核心思想

**Agent-as-Tool** 模式将智能体（Agent）包装成函数工具（Function Tool），使其可以被其他 Agent 像调用普通函数一样调用。这是一个**适配器模式（Adapter Pattern）**的变体。

```
┌─────────────────────────────────────────────────────────┐
│                    调度器 (Orchestrator)                 │
│  "我只知道有哪些工具，不关心工具内部是什么"              │
└─────────────────────────────────────────────────────────┘
                          │ 调用工具
                          ▼
┌─────────────────────────────────────────────────────────┐
│              Agent-as-Tool 适配器层                      │
│  @function_tool                                          │
│  async def consult_technical_expert(query: str) -> str   │
└─────────────────────────────────────────────────────────┘
                          │ 内部启动 Runner
                          ▼
┌─────────────────────────────────────────────────────────┐
│                 技术专家 Agent                           │
│  (复杂的 Agent 对象，有自己的工具和逻辑)                 │
└─────────────────────────────────────────────────────────┘
```

### 3. 核心实现

```python
from agents import function_tool, Runner
from agents.run import RunConfig

# 1. 定义下游 Agent
technical_agent = Agent(
    name="技术专家",
    instructions="你是一个技术维修专家...",
    tools=[query_knowledge, web_search]
)

# 2. 将 Agent 包装为 Tool
@function_tool
async def consult_technical_expert(query: str) -> str:
    """
    【咨询技术专家】处理技术咨询、设备故障、维修建议。

    Args:
        query: 用户的原始问题或完整指令

    Returns:
        技术专家的回答
    """
    try:
        result = await Runner.run(
            technical_agent,
            input=query,
            run_config=RunConfig(tracing_disabled=True)
        )
        return result.final_output
    except Exception as e:
        return f"技术专家暂时无法回答: {str(e)}"

# 3. 调度器只需注册工具
orchestrator = Agent(
    name="调度器",
    instructions="技术问题 → consult_technical_expert ...",
    tools=[consult_technical_expert]  # 无需了解实现细节
)
```

### 4. 设计优势

| 维度 | 直接调用 Agent | Agent-as-Tool |
|------|---------------|---------------|
| **调度器职责** | 管理 Agent 对象、配置 Runner | 只负责意图识别和工具选择 |
| **代码耦合度** | 高（需要导入所有 Agent 类） | 低（只导入工具函数） |
| **修改影响范围** | Agent 改动影响调度器 | Agent 改动不影响调度器 |
| **测试难度** | 需要 Mock 整个 Agent 系统 | 可以独立测试每个工具 |

### 5. 最佳实践

1. **透传原始问题**：直接传递用户问题，不做加工，让下游 Agent 自己理解
2. **禁用嵌套追踪**：`RunConfig(tracing_disabled=True)` 避免日志污染
3. **详细的工具描述**：LLM 会读取 docstring 来决定是否调用工具，清晰描述 = 更准确的工具选择
4. **统一的错误信息格式**：防止单个 Agent 崩溃导致整个系统崩溃

### 6. 常见陷阱

1. **过度包装**：简单逻辑不需要包装成 Agent Tool，直接写成普通函数
2. **工具描述不清晰**：模糊的描述导致 LLM 选错工具
3. **忘记错误处理**：未捕获异常会导致整个系统崩溃
4. **循环依赖**：Agent 之间互相调用，使用单向依赖（调度器 → 专家 Agent）

### 7. 适用场景

- ✅ 多智能体协作系统、需要动态路由的对话系统、复杂的任务分解场景
- ❌ 简单的单 Agent 系统、工具逻辑非常简单、不需要 Agent 协作的场景

---

**版本**: v1.0 | **日期**: 2026-01-26 ~ 2026-01-29
